#!/usr/bin/env python
# coding=utf-8
"""
Annuity calculation, based on VDI 2067 (standard of German association of
engineers) - Economic efficiency of building installations
Fundamentals and economic calculation (ICS 91.140.01)
"""

import math
import warnings


class EconomicCalculation(object):
    """
    Class to perform economic calculations
    """

    def __init__(self, germanmarket=None, time=10, interest=0.05,
                 method='vdi2067',
                 run_init_calc=True, price_ch_cap=1.03,
                 price_ch_dem_gas=1.02, price_ch_dem_el=1.02,
                 price_ch_dem_cool=1.02,
                 price_ch_op=1.017, price_ch_proc_chp=1.01,
                 price_ch_proc_pv=0.975,
                 price_ch_eeg_chp=1,
                 price_ch_eeg_pv=1,
                 price_ch_eex=0.99,
                 price_ch_grid_use=1,
                 price_ch_chp_sub=1,
                 price_ch_chp_self=1,
                 price_ch_chp_tax_return=1,
                 price_ch_pv_sub=0.97):

        """
        Constructor of Economic calculator instance.

        Parameters
        ----------
        germanmarket : object, optional
            GermanMarket object of pyCity_calc (default: None)
        time : int, optional
            Time for economic calculation in years (default: 10)
        interest : float, optional
            Interest rate for economic calculation (default: 0.05)
        method : str, optional
            Method of calculation (default: 'vdi2067')
            Options:
            'vdi2067' : Annuity calculation based on VDI 2067 standard
            'year_specific' : Uses year dependend price change factors,
            e.g. generated by Brownian motion (to be implemented)
        run_init_calc : bool, optional
            Defines, if initial calculations (such as annuity factor)
            should be calculated (default: True)
        price_ch_cap : float, optional
            Price change factor of capital (default: 1.03)
            Only used, if method == 'vdi2068'
        price_ch_dem_gas : float, optional
            Price change factor demand (gas) (default: 1.02)
            Only used, if method == 'vdi2068'
        price_ch_dem_el : float, optional
            Price change factor demand (el.) (default: 1.02)
            Only used, if method == 'vdi2068'
        price_ch_dem_cool : float, optional
            Price change factor for (district) cooling (default: 1.02)
            Only used, if method == 'vdi2068'
        price_ch_op : float, optional
            Price change factor operations (default: 1.017)
            Only used, if method == 'vdi2068'
        price_ch_proc_chp : float, optional
            Price change factor proceedings (CHP) (default: 1.01)
            Only used, if method == 'vdi2068'
        price_ch_proc_pv : float, optional
            Price change factor proceedings (PV) (default: 0.975)
            Only used, if method == 'vdi2068'
        price_ch_eeg_chp : float, optional
            Price change factor of EEG payment for self consumed CHP el.
            energy (default: 1)
        price_ch_eeg_pv : float, optional
            Price change factor of EEG payment for self consumed PV el.
            energy (default: 1)
        price_ch_eex : float, optional
            Price change factor of EEX baseload price (default: 0.99)
        price_ch_grid_use : float, optional
            Price change factor of grid usage fee (default: 1)
        price_ch_chp_sub : float, optional
            Price change factor of CHP subsidies for fed-in electricity
            (default: 1)
        price_ch_chp_self : float, optional
            Price change factor for CHP subsidies for self consumed el. CHP
            energy (default: 1)
        price_ch_chp_tax_return : float, optional
            Price change factor of CHP tax return on gas usage (default: 1)
        price_ch_pv_sub : float, optional
            Price change factor on PV subsidies for fed-in electricity
            (default: 0.97)
        """

        #  Assert statements
        #  ################################################################

        assert time > 0, 'time in years has to be larger than 0!'
        assert interest > 0, 'interest should be larger than 0!'
        assert interest <= 1, 'Unrealistic interest rate. Check input. '

        list_methods = ['vdi2067', 'year_specific']
        assert method in list_methods, 'Unknown method chosen. Check input!'

        #  TODO: Change, after year_specific method has been implemented
        if method == 'year_specific':
            msg = 'Not implemented, yet!'
            raise AssertionError(msg)

        list_price_change_factors = [price_ch_cap, price_ch_dem_gas,
                                     price_ch_dem_el, price_ch_op,
                                     price_ch_proc_chp, price_ch_proc_pv]

        for factor in list_price_change_factors:
            msg = 'Price change rate seems to be unrealistic, please check ' \
                  'input factors.'
            if (factor < 0.9 or factor > 1.1):  # limits of -/+ 10 % per year
                warnings.warn(msg)

        # General attributes
        # ################################################################

        self.germanmarket = germanmarket  # GermanMarket object pointer
        self.time = time  # Time in years
        self.interest = interest  # Internal interest rate i (e.g. 0.05)
        self.interest_factor = 1 + interest  # Interest factor q  (e.g. 1.05)
        self.method = method  # Calculation method

        #  Dummy values for annuity factor, price change factors
        #  and price dynamic factors (dependent on chosen method)
        #  ###############################################################

        self.ann_factor = None  # Annuity factor

        #  Price change factors
        self.price_ch_cap = None  # Price change factor of capital (e.g. 1.05)
        self.price_ch_dem_gas = None  # Price change factor demand (gas)
        self.price_ch_dem_el = None  # Price change factor demand (el.)
        self.price_ch_dem_cool = None  # Price change factor (cooling)
        self.price_ch_op = None  # Price change factor operations
        self.price_ch_proc_chp = None  # Price change factor proceedings (CHP)
        self.price_ch_proc_pv = None  # Price change factor proceedings (PV)

        self.price_ch_eeg_chp = None
        self.price_ch_eeg_pv = None
        self.price_ch_eex = None
        self.price_ch_grid_use = None
        self.price_ch_chp_sub = None
        self.price_ch_chp_self = None
        self.price_ch_chp_tax_return = None
        self.price_ch_pv_sub = None

        #  Price dynamic value factors
        self.price_dyn_cap = None
        self.price_dyn_dem_gas = None
        self.price_dyn_dem_el = None
        self.price_dyn_dem_cool = None
        self.price_dyn_op = None
        self.price_dyn_proc_chp = None
        self.price_dyn_proc_pv = None

        # Subsidy dynamic factors
        self.price_dyn_eeg_chp = None
        self.price_dyn_eeg_pv = None
        self.price_dyn_eex = None
        self.price_dyn_grid_use = None
        self.price_dyn_chp_sub = None
        self.price_dyn_chp_self = None
        self.price_dyn_chp_tax_return = None
        self.price_dyn_pv_sub = None

        #  Dictionaries withe lifetimes and maintenance factors
        ###################################################################

        self.dict_components = \
            {'LHN_station': 'Local heating network transfer station',
             'LHN_steel_pipe': 'Local heating network steel pipe',
             'LHN_plastic_pipe': 'Local heating network plastic pipe',
             'B': 'Boiler',
             'HP': 'Heat pump',
             'EH': 'Electrical heater',
             'CHP': 'Combined heat and power unit',
             'TES': 'Thermal storage / hot water tank',
             'PV': 'Photovoltaic modul',
             'BAT': 'Electrical batttery',
             'DEG': 'Decentralized, electrical grid'}

        #  Dictionaries with lifetime of components (VDI 2067)
        self.dict_lifetimes = {'LHN_station': 30,
                               'LHN_steel_pipe': 40,
                               'LHN_plastic_pipe': 30,
                               'B': 18,
                               'HP': 20,
                               'EH': 20,
                               'CHP': 15,
                               'TES': 20,
                               'PV': 25,
                               'BAT': 15,
                               'DEG': 15}

        #  Dictionaries with maintenance, inspection and repair factors
        self.dict_maintenance = {'LHN_station': 0.03,
                                 'LHN_steel_pipe': 0.01,
                                 'LHN_plastic_pipe': 0.01,
                                 'B': 0.03,
                                 'HP': 0.025,
                                 'EH': 0.03,
                                 'CHP': 0.08,
                                 'TES': 0.02,
                                 'PV': 0.02,
                                 'BAT': 0.04,
                                 'DEG': 0.03}

        #  Dictionary with number of replacements per component
        self.dict_nb_replacements = {}

        if run_init_calc:
            #  Run initial calculations and save results back to object
            #  #############################################################

            #  Calculate annuity factor (saved to self.ann_factor)
            self.calc_annuity_factor()

            #  Calculate number of replacements per type of energy system
            self.calc_nb_of_replacements()

            #  If default VDI 2067 is used
            #  #############################################################
            if method == 'vdi2067':
                #  Calculate VDI 2067 factors (r)
                self.price_ch_cap = price_ch_cap
                # Price change factor of capital (e.g. 1.05)
                self.price_ch_dem_gas = price_ch_dem_gas
                # Price change factor demand (gas)
                self.price_ch_dem_el = price_ch_dem_el
                # Price change factor demand (el.)
                self.price_ch_dem_cool = price_ch_dem_cool
                #  Price change factor cooling
                self.price_ch_op = price_ch_op
                # Price change factor operations
                self.price_ch_proc_chp = price_ch_proc_chp
                # Price change factor proceedings (CHP)
                self.price_ch_proc_pv = price_ch_proc_pv
                # Price change factor proceedings (PV)

                self.price_ch_eeg_chp = price_ch_eeg_chp
                self.price_ch_eeg_pv = price_ch_eeg_pv
                self.price_ch_eex = price_ch_eex
                self.price_ch_grid_use = price_ch_grid_use
                self.price_ch_chp_sub = price_ch_chp_sub
                self.price_ch_chp_self = price_ch_chp_self
                self.price_ch_chp_tax_return = price_ch_chp_tax_return
                self.price_ch_pv_sub = price_ch_pv_sub

                #  Calculate dynamic value factors (b)
                self.price_dyn_cap = self.calc_price_dyn_factor(
                    self.price_ch_cap)
                self.price_dyn_dem_gas = \
                    self.calc_price_dyn_factor(self.price_ch_dem_gas)
                self.price_dyn_dem_el = \
                    self.calc_price_dyn_factor(self.price_ch_dem_el)
                self.price_dyn_dem_cool = \
                    self.calc_price_dyn_factor(self.price_ch_dem_cool)
                self.price_dyn_op = self.calc_price_dyn_factor(
                    self.price_ch_op)
                self.price_dyn_proc_chp = \
                    self.calc_price_dyn_factor(self.price_ch_proc_chp)
                self.price_dyn_proc_pv = \
                    self.calc_price_dyn_factor(self.price_ch_proc_pv)

                self.price_dyn_eeg_chp = \
                    self.calc_price_dyn_factor(
                        self.price_ch_eeg_chp)
                self.price_dyn_eeg_pv = \
                    self.calc_price_dyn_factor(self.price_ch_eeg_pv)
                self.price_dyn_eex = \
                    self.calc_price_dyn_factor(self.price_ch_eex)
                self.price_dyn_grid_use = \
                    self.calc_price_dyn_factor(self.price_ch_grid_use)
                self.price_dyn_chp_sub = \
                    self.calc_price_dyn_factor(self.price_ch_chp_sub)
                self.price_dyn_chp_self = \
                    self.calc_price_dyn_factor(self.price_ch_chp_self)
                self.price_dyn_chp_tax_return = \
                    self.calc_price_dyn_factor(self.price_ch_chp_tax_return)
                self.price_dyn_pv_sub = \
                    self.calc_price_dyn_factor(self.price_ch_pv_sub)

    def __str__(self):
        return str('<EconomicCalculator object of PyCity_Calc with ' +
                   str(self.time) + ' years calculation time and '
                   + str(self.interest) + ' internal interest '
                                          ' and method ' + str(
            self.method) + '>')

    def get_dict_of_valid_components(self):
        """
        Returns dictionary of valid components with name-tag as key and
        explanation (string) as value

        Returns
        -------
        self.dict_components : dict
            Dictionary with names and explanations of valid components
        """

        return self.dict_components

    def get_dict_of_lifetimes(self):
        """
        Returns dictionary of lifetimes per component with component tag
        as key and lifetime in years as value.

        Returns
        -------
        self.dict_lifetimes : dict
            Dictionary of lifetimes per component in years
        """

        return self.dict_lifetimes

    def get_dict_of_maintenance_factors(self):
        """
        Returns dictionary of maintenance factors per component with
        component tag as key and lifetime in years as value.

        Returns
        -------
        self.dict_maintenance : dict
            Dictionary of maintenance factors per component
        """

        return self.dict_maintenance

    #  Methods for initial calculation (annuity factors and nb. replacements)
    #  ####################################################################

    def calc_annuity_factor(self, save_factor=True):
        """
        Calculate annuity factor ann_factor.

        Parameters
        ----------
        save_factor : bool, optional
            Defines, if annuity factor should be saved back to
            EconomicCalculation object (default: True)

        Returns
        -------
        ann_factor : float
            Annuity factor

        Annotations
        -----------
        a = q^T * (q - 1) / (q^T - 1)  = (q - 1) / (1 - q ^(-1))
        """

        #  Make simple named pointers
        q = self.interest_factor
        t = self.time

        #  Calculate annuity factor
        ann_factor = (q ** t * (q - 1)) / (q ** t - 1)

        #  Save it back to object
        if save_factor:
            self.ann_factor = ann_factor

        return ann_factor

    def calc_nb_of_replacements(self):
        """
        Calculates dictionary of number of replacements per component and
        save results back to self.dict_nb_replacements
        """

        #  Loop over energy system names
        for key in self.dict_lifetimes:

            #  Current lifetime of component
            curr_lifetime = self.dict_lifetimes[key]

            #  If lifetime is larger than observation time,
            #  no replacement purchases have to be made
            if curr_lifetime >= self.time:
                nb_replace = 0
            else:
                #  If no remainder of division is given, reduce by one
                if self.time % curr_lifetime == 0:
                    nb_replace = math.floor(self.time / curr_lifetime) - 1
                else:
                    #  Calculate number of replacements (round down)
                    nb_replace = math.floor(self.time / curr_lifetime)

            # Save number of replacements to dict
            self.dict_nb_replacements[key] = nb_replace

    # ####################################################################

    def calc_price_dyn_factor(self, price_ch_factor):
        """
        Calculate price dynamic value factor b

        Parameters
        ----------
        price_ch_factor : float
            Price change factor r (such as 1.03 for 3 % increase per year)

        Returns
        -------
        price_dyn_fac : float
            Price dynamic value factor

        Annotations
        -----------
        b = (1 - (r/q)^T) / (q - r)
        If r == q --> b = T/q
        """

        if price_ch_factor == self.interest_factor:
            price_dyn_fac = self.time / self.interest_factor

        else:
            #  Make simple name pointers
            r = price_ch_factor
            q = self.interest_factor
            t = self.time

            price_dyn_fac = (1 - (r / q) ** t) / (q - r)

        return price_dyn_fac

    #  #  Capital related cost
    #  #################################################################
    def calc_cash_value_for_single_replacement(self, invest, price_change,
                                               nb_replacement, lifetime):
        """
        Calculates and returns the cash value of one replacement

        Parameters
        ----------
        invest : float
            Investment of component at time t0 (A0 value)
        price_change : float
            Cash price change factor (such as 1.02 for 2 % increase per year)
        nb_replacement : int
            The actual replacement number of component
            (NOT total number of replacements!)
            Example: If this is the first replacement of two replacements,
            1 has to be used.
        lifetime : int
            Lifetime of component in years

        Returns
        -------
        cash_val_repl : float
            Cash value of replacement

        Annotations
        -----------
        An = A0 * r^(n * T_n) / q^(n * T_n)
        """

        #  Get pointer for interest factor
        q = self.interest_factor

        cash_val_repl = invest * ((price_change ** (nb_replacement * lifetime))
                                  / (q ** (nb_replacement * lifetime)))

        return cash_val_repl

    def calc_sum_cash_value_factors_replacements(self, invest, type):
        """
        Calculates sum of all cash values for all replacements per component,
        depending on initial investment cost and lifetime of component.

        Parameters
        ----------
        invest : float
            Investment of component at time t0 (A0 value)
        type : str
            Type of component. Options:
            'LHN_station'
            'LHN_steel_pipe'
            'LHN_plastic_pipe'
            'B' : Boiler
            'HP' : Heat pump
            'EH' : Electrical heater
            'CHP' : Combined heat and power unit
            'TES' : Thermal storage
            'PV' : Photovoltaic
            'BAT' : Electrical batttery
            'DEG' : Decentralized, electrical grid

        Returns
        -------
        cash_val_repl_sum : float
            Sum of all cash value replacements
        """

        #  Get dict of valid components
        dict_valid = self.get_dict_of_valid_components()

        #  Check if component is valid
        if type not in dict_valid:
            msg = 'Type of component is unknown. Check your input for type.'
            raise AssertionError(msg)

        # Access price change rate of cash
        r_cash = self.price_ch_cap

        if r_cash is None:
            msg = 'Price change rate of cash has to be defined!'
            raise AssertionError(msg)

        # Get number of replacements for component type
        total_nb_repl = self.dict_nb_replacements[type]

        if total_nb_repl is None:
            msg = 'Total number of replacements has to be calculated, first'
            raise AssertionError(msg)

        # Get lifetime of component
        lifetime = self.dict_lifetimes[type]

        #  Loop over number of replacements to calc. cash value factor
        #  for every relacement and sum these values up
        cash_val_repl_sum = 0

        for rep in range(1, total_nb_repl + 1):
            repl_cash = \
                self.calc_cash_value_for_single_replacement(invest=invest,
                                                            price_change=r_cash,
                                                            nb_replacement=rep,
                                                            lifetime=lifetime)

            #  Sum values up
            cash_val_repl_sum += repl_cash

        return cash_val_repl_sum

    def calc_residual_value(self, invest, type):
        """
        Calculate and return residual value of component in Euro.

        Parameters
        ----------
        invest : float
            Investment at time t0 into component in Euro
        type : str
            Type of component. Options:
            'LHN_station'
            'LHN_steel_pipe'
            'LHN_plastic_pipe'
            'B' : Boiler
            'HP' : Heat pump
            'EH' : Electrical heater
            'CHP' : Combined heat and power unit
            'TES' : Thermal storage
            'PV' : Photovoltaic
            'BAT' : Electrical batttery
            'DEG' : Decentralized, electrical grid

        Returns
        -------
        residual_val : float
            Residual value of component at end of observation time in Euro

        Annotations
        -----------
        R_w = A0 * r^(n * T_n) * ((n + 1) * T_N - T) / (T_N * q^T)
        """

        #  Get dict of valid components
        dict_valid = self.get_dict_of_valid_components()

        #  Check if component is valid
        if type not in dict_valid:
            msg = 'Type of component is unknown. Check your input for type.'
            raise AssertionError(msg)

        # Define simple named pointers
        r = self.price_ch_cap  # Price change factor r for capital
        n = self.dict_nb_replacements[type]  # Number of replacements
        t_n = self.dict_lifetimes[type]  # Lifetime in years
        t = self.time  # Obversation time in years
        q = self.interest_factor  # Interest factor

        #  Check if replacements took place during observation period
        if n > 0:
            #  If replacements to place, use cash value of last replacement

            #  Calculate cash value for last replacement
            cash_last_rep = \
                self.calc_cash_value_for_single_replacement(invest=invest,
                                                            price_change=r,
                                                            nb_replacement=n,
                                                            lifetime=t_n)
            a_0 = cash_last_rep

        else:  # Use original investment cost
            a_0 = invest

        residual_val = a_0 * (r ** (n * t_n)) * \
                       ((((n + 1) * t_n) - t) / t_n) * 1 / (q ** t)

        return residual_val

    def calc_capital_rel_annuity(self, invest, sum_repl, residual):
        """
        Calculate and return capital-related annuity

        Parameters
        ----------
        invest : float
            Sum of investments at time t0 (total investment) in Euro
        sum_repl : float
            Sum of all replacement cash values in Euro
        residual : float
            Sum of residual values at end of observation time in Euro

        Returns
        -------
        cap_rel_annuity : float
            Capital-related annuity in Euro

        Annotations
        -----------
        A_N_K = (A0 + A1 + ... + An - R_w) * a
        """

        #  Get simple named pointers
        a = self.ann_factor  # Annuity factor

        cap_rel_annuity = (invest + sum_repl - residual) * a

        return cap_rel_annuity

    def calc_capital_rel_annuity_with_type(self, invest, type):
        """
        Calculates the capital-related annuity by pre-calculationg
        the sum of all re-investments for replacement purchases and the
        residual value at the end of the observation period.

        Parameters
        ----------
        invest : float
            Investment of component at time t0 (A0 value)
        type : str
            Type of component. Options:
            'LHN_station'
            'LHN_steel_pipe'
            'LHN_plastic_pipe'
            'B' : Boiler
            'HP' : Heat pump
            'EH' : Electrical heater
            'CHP' : Combined heat and power unit
            'TES' : Thermal storage
            'PV' : Photovoltaic
            'BAT' : Electrical batttery
            'DEG' : Decentralized, electrical grid

        Returns
        -------
        cap_rel_annuity : float
            Capital-related annuity in Euro
        """

        #  Sum of all cash values for replacements
        cash_rep_sum = \
            self.calc_sum_cash_value_factors_replacements(invest=invest,
                                                          type=type)

        #  Residual value
        res_value = self.calc_residual_value(invest=invest, type=type)

        cap_rel_annuity = \
            self.calc_capital_rel_annuity(invest=invest,
                                          sum_repl=cash_rep_sum,
                                          residual=res_value)

        return cap_rel_annuity

    #  #  Demand-related costs
    #  #################################################################
    def calc_dem_rel_annuity(self, sum_el_e=0, sum_gas_e=0, sum_cool_e=0,
                             price_el=0, price_gas=0, price_cool=0):
        """
        Calculate and return annuity of demand-related cost in Euro.
        (only valid for VDI2067 calculation method)

        Parameters
        ----------
        sum_el_e : float, optional
            Sum of electrical energy demand, which has to be payed (in kWh)
            (default: 0)
        sum_gas_e : float, optional
            Sum of thermal energy demand, which has to be payed (in kWh)
            (default: 0)
        sum_cool_e : float, optional
            Sum of cooling energy demand, which has to be payed (in kWh)
            (default: 0)
        price_el : float, optional
            Specific price of electricity (in Euro/kWh)
            (default: 0)
        price_gas : float, optional
            Specific price of thermal energy (in Euro/kWh)
            (default: 0)
        price_cool : float, optional
            Specific price of electricity (in Euro/kWh)
            (default: 0)

        Returns
        -------
        dem_rel_annuity : float
            Demand-related annuity

        Annotations
        -----------
        A_N_V = A_V_1 * a * b_v
        A_V_1 = Energy * price/unit + Energy ...
        """
        #  TODO: Add further discretization (e.g. DH or oil supply at other prices)
        #  TODO: Differ in pricing (e.g. res. and industry...)

        #  Asserts
        if sum_el_e > 0:
            assert price_el > 0, 'Specific price has to be larger than zero!'
        if sum_gas_e > 0:
            assert price_gas > 0, 'Specific price has to be larger than zero!'
        if sum_cool_e > 0:
            assert price_cool > 0, 'Specific price has to be larger than zero!'

        # Define simple named pointers
        b_el = self.price_dyn_dem_el  # Price dynamic factor el.
        b_gas = self.price_dyn_dem_gas  # Price dynamic factor gas
        b_cool = self.price_dyn_dem_cool

        #  Calculate demand-related cost per year
        dem_rel_cost = b_el * sum_el_e * price_el + \
                       b_gas * sum_gas_e * price_gas + \
                       b_cool * sum_cool_e * price_cool

        return dem_rel_cost * self.ann_factor

    def calc_eeg_self_con(self, en_chp_self=None, en_chp_pv=None):
        """
        Calculate EEG payment on self-produced and consumed electric energy of
        PV and CHP systems

        Parameters
        ----------
        en_chp_self : float
            Amount of self-produced and consumed el. energy of CHP in kWh/a
        en_chp_pv : float
            Amount of self-produced and consumed el. energy of PV in kWh/a

        Returns
        -------
        eeg_payment : float
            Annualized EEG payment in Euro/a
        """

        if self.germanmarket is None:
            msg = 'Requires GermanMarket object (currently None!)'
            raise AssertionError(msg)

        #  Pointers to price dynamic factors
        b_eeg_chp = self.price_dyn_eeg_chp
        b_eeg_pv = self.price_dyn_eeg_pv

        eeg_chp = self.germanmarket.get_eeg_payment(type='chp')
        eeg_pv = self.germanmarket.get_eeg_payment(type='pv')

        eeg_payment = b_eeg_chp * en_chp_self * eeg_chp  + \
                      b_eeg_pv * en_chp_pv * eeg_pv

        return eeg_payment

    #  Operation-related costs
    #################################################################
    def calc_op_rel_annuity_single_comp(self, invest, type):
        """
        Calculate operation-related annuity for single component.

        Parameters
        ----------
        invest : float
            Investment at time t0 into component in Euro
        type : str
            Type of component. Options:
            'LHN_station'
            'LHN_steel_pipe'
            'LHN_plastic_pipe'
            'B' : Boiler
            'HP' : Heat pump
            'EH' : Electrical heater
            'CHP' : Combined heat and power unit
            'TES' : Thermal storage
            'PV' : Photovoltaic
            'BAT' : Electrical batttery
            'DEG' : Decentralized, electrical grid

        Returns
        -------
        op_rel_annuity : float
            Operation-related annuity of single component

        Annotations
        -----------
        A_N_B = (A_0 * (f_inst + f_insp)) * a * b_in
        """

        #  Get dict of valid components
        dict_valid = self.get_dict_of_valid_components()

        #  Check if component is valid
        if type not in dict_valid:
            msg = 'Type of component is unknown. Check your input for type.'
            raise AssertionError(msg)

        # Calculate operation-related cost of component for one year
        op_rel_cost = invest * self.dict_maintenance[type]

        #  Calculate operation-related annuity in Euro
        return op_rel_cost * self.ann_factor * self.price_dyn_op

    def calc_op_rel_annuity_multi_comp(self, list_invest, list_types):
        """
        Calculate operation-related annuity for multi components.

        Input lists need to be in corresponding order (invest to type)

        Parameters
        ----------
        list_invest : list (of floats)
            List holding investments per component at time t0 in Euro
        list_type : list (of str)
            List holding different energy system types
                Type options:
                'LHN_station'
                'LHN_steel_pipe'
                'LHN_plastic_pipe'
                'B' : Boiler
                'HP' : Heat pump
                'EH' : Electrical heater
                'CHP' : Combined heat and power unit
                'TES' : Thermal storage
                'PV' : Photovoltaic
                'BAT' : Electrical batttery
                'DEG' : Decentralized, electrical grid

        Returns
        -------
        op_rel_annuity : float
            Operation-related annuity of multiple components
        """

        assert len(list_invest) == len(list_types), 'List do not have ' \
                                                    'same length!'

        op_rel_annuity = 0  # Dummy value

        for i in range(len(list_invest)):
            curr_invest = list_invest[i]
            curr_type = list_types[i]

            #  Get operation-related annuity of single component
            curr_op_rel_ann = \
                self.calc_op_rel_annuity_single_comp(invest=curr_invest,
                                                     type=curr_type)

            op_rel_annuity += curr_op_rel_ann

        return op_rel_annuity

    #  #  Proceedings
    #  #################################################################
    def calc_proc_annuity_single_comp(self, spec_income, sold_energy, type,
                                      spec_income_type=None):
        """
        Calculate proceedings annuity for single component (such as CHP or PV)

        Parameters
        ----------
        spec_income : float
            Specific price per sold unit of energy (in Euro/kWh)
        sold_energy : float
            Amount of sold energy (in kWh)
        type : str
            Type of energy system.
            Options:
            - 'CHP'
            - 'PV'
        spec_income_type : str
            Type of the specific income.
            - 'EEG_Umlage_tax'
            - 'EEX_baseload_price'
            - 'avoid_grid_usage'
            - 'sub_chp'
            - 'self_usage_chp'
            - 'gas_disc_chp'
            - 'sub_pv'


        Returns
        -------
        proc_annuity : float
            Annuity of proceedings for single component in Euro
        """
        #  TODO: might find better names! Added by Simon Wilbertz
        if spec_income_type == 'EEG_Umlage_tax':
            if type == 'CHP':
                dyn_fac = self.price_dyn_EEG_Umlage_tax_chp
            elif type == 'PV':
                dyn_fac = self.price_dyn_EEG_Umlage_tax_pv

        elif spec_income_type == 'EEX_baseload_price':
            dyn_fac = self.price_dyn_EEX_baseload_price

        elif spec_income_type == 'avoid_grid_usage':
            dyn_fac = self.price_dyn_avoid_grid_usage

        elif spec_income_type == 'sub_chp':
            dyn_fac = self.price_dyn_sub_chp

        elif spec_income_type == 'self_usage_chp':
            dyn_fac = self.price_dyn_self_usage_chp

        elif spec_income_type == 'gas_disc_chp':
            dyn_fac = self.price_dyn_gas_disc_chp

        elif spec_income_type == 'sub_pv':
            dyn_fac = self.price_dyn_sub_pv

        elif spec_income_type == None:
            if type == 'CHP':
                dyn_fac = self.price_dyn_proc_chp
            elif type == 'PV':
                dyn_fac = self.price_dyn_proc_pv

        return spec_income * sold_energy * self.ann_factor * dyn_fac

    def calc_proc_annuity_multi_comp(self, list_spec_income, list_sold_energy,
                                     list_types):
        """
        Calculate proceedings annuity for multi components (such as CHP or PV)

        Input list need to be in corresponding order

        Parameters
        ----------
        list_spec_income : list (of floats)
            List holding specific prices per sold unit of energy (in Euro/kWh)
        list_sold_energy : list (of floats)
            List holding amount of sold energy (in kWh)
        list_types : list (of str)
            List holding types of energy system
                Options:
                - 'CHP'
                - 'PV'

        Returns
        -------
        proc_annuity : float
            Annuity of proceedings for multi components in Euro
        """

        assert len(list_spec_income) == len(list_sold_energy)
        assert len(list_spec_income) == len(list_types)

        proc_annuity = 0  # Dummy value

        #  Loop over list entries
        for i in range(len(list_spec_income)):
            curr_spec_in = list_spec_income[i]
            curr_sold_e = list_sold_energy[i]
            curr_type = list_types[i]

            #  Calculate proceedings-related annuity for single component
            curr_proc_ann = \
                self.calc_proc_annuity_single_comp(spec_income=curr_spec_in,
                                                   sold_energy=curr_sold_e,
                                                   type=curr_type)

            proc_annuity += curr_proc_ann

        return proc_annuity

    #  # Total annuity
    #  #################################################################
    def calc_total_annuity(self, ann_capital, ann_demand, ann_op, ann_proc):
        """
        Calculate total annuity.

        Input values need to be positive. Capital, demand and operation
        related annuities get a minus sign, while proceeding related annuity
        get a positive sign for calculation.

        Parameters
        ----------
        ann_capital : float
            Capital-related annuity in Euro (>= 0)
        ann_demand : float
            Demand-related annuity in Euro (>= 0)
        ann_op : float
            Operation-related annuity in Euro (>= 0)
        ann_proc : float
            Proceedings-related annuity in Euro (>= 0)

        Returns
        -------
        annuity : float
            Total annuity in Euro
        """

        # assert ann_capital >= 0, 'Annuity has to be positive. Check input.'
        # assert ann_demand >= 0, 'Annuity has to be positive. Check input.'
        # assert ann_op >= 0, 'Annuity has to be positive. Check input.'
        # assert ann_proc >= 0, 'Annuity has to be positive. Check input.'

        return ann_proc - (ann_capital + ann_demand + ann_op)


if __name__ == '__main__':
    time = 30
    interest = 0.05  # 0 < interest <= 1
    method = 'vdi2067'

    #  Generate Economic Calculator object instance
    #  ####################################################################
    #  Initialize EconomicCalculation object
    #  Generate lifetime, maintenance factor and nb. of replacement dicts
    #  Calculate annuity factor as eco_calc.ann_factor
    #  Calculate dynamic value factors
    #  ####################################################################
    eco_calc = EconomicCalculation(time=time, interest=interest, method=method)
    print(eco_calc)
    print()

    #  Get annuity factor
    ann_factor = eco_calc.ann_factor

    print('Annuity factor:')
    print(ann_factor)
    print()

    #  Test run with boiler
    #  ###############################################
    print('Test run with boiler')
    print('#################################################')
    print()

    #  Inputs
    boiler_invest = 5000  # Euro
    type_1 = 'B'  # Boiler

    chp_invest = 20000  # Euro
    type_2 = 'CHP'

    #  Get number of replacments of
    print('Number of necessary replacements of boiler:')
    print(eco_calc.dict_nb_replacements[type_1])
    print('Number of necessary replacements of CHP:')
    print(eco_calc.dict_nb_replacements[type_2])
    print()

    #  Calculate cash value for replacements
    sum_repl_cash_b = \
        eco_calc.calc_sum_cash_value_factors_replacements(invest=boiler_invest,
                                                          type=type_1)
    sum_repl_cash_chp = \
        eco_calc.calc_sum_cash_value_factors_replacements(invest=chp_invest,
                                                          type=type_2)
    print('Sum of all replacement cash values (boiler) in Euros:')
    print(round(sum_repl_cash_b, 2))
    print('Sum of all replacement cash values (CHP) in Euros:')
    print(round(sum_repl_cash_chp, 2))
    print()

    #  Calculate residual value of boiler
    res_val_boiler = eco_calc.calc_residual_value(invest=boiler_invest,
                                                  type=type_1)
    res_val_chp = eco_calc.calc_residual_value(invest=chp_invest,
                                               type=type_2)
    print('Residual value of boiler at the end of observation period in Euro:')
    print(round(res_val_boiler, 2))
    print('Residual value of CHP at the end of observation period in Euro:')
    print(round(res_val_chp, 2))
    print()

    #  Sum up investments
    total_invest = boiler_invest + chp_invest
    total_repl_cash = sum_repl_cash_b + sum_repl_cash_chp
    total_residuals = res_val_boiler + res_val_chp

    #  Calculate total capital related annuity
    cap_rel_annuity = \
        eco_calc.calc_capital_rel_annuity(invest=total_invest,
                                          sum_repl=total_repl_cash,
                                          residual=total_residuals)
    print('Total capital-related annuity in Euros:')
    print(round(cap_rel_annuity, 2))
    print()

    #  Calculate demand-related annuity
    #  ##################################################################

    sum_el = 5000  # kWh
    sum_gas = 40000  # kWh

    price_gas = 0.06  # Euro/kWh
    price_el = 0.26  # Euro/kWh

    dem_rel_annuity = \
        eco_calc.calc_dem_rel_annuity(sum_el_e=sum_el, sum_gas_e=sum_gas,
                                      price_el=price_el, price_gas=price_gas)
    print('Demand-related annuity in Euro:')
    print(round(dem_rel_annuity, 2))
    print()

    #  Calculate operation-related annuity
    #  ##################################################################
    list_invest = [boiler_invest, chp_invest]
    list_types = [type_1, type_2]

    op_rel_annuity = \
        eco_calc.calc_op_rel_annuity_multi_comp(list_invest, list_types)
    print('Operation-related annuity in Euro:')
    print(round(op_rel_annuity, 2))
    print()

    #  Calculate proceedings-related annuity
    #  ##################################################################
    list_spec_proc = [0.1, 0.11]
    list_sold_energy = [5000, 2000]
    list_types = ['CHP', 'PV']

    proc_rel_annuity = \
        eco_calc.calc_proc_annuity_multi_comp(list_spec_income=list_spec_proc,
                                              list_sold_energy=list_sold_energy,
                                              list_types=list_types)
    print('Proceeding-related annuity in Euro:')
    print(round(proc_rel_annuity, 2))
    print()

    #  Calculate total annuity
    #  ##################################################################
    total_annuity = \
        eco_calc.calc_total_annuity(ann_capital=cap_rel_annuity,
                                    ann_demand=dem_rel_annuity,
                                    ann_op=op_rel_annuity,
                                    ann_proc=proc_rel_annuity)
    print('Total annuity in Euro:')
    print(round(total_annuity, 2))
